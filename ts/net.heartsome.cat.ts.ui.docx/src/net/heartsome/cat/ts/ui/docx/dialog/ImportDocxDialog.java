package net.heartsome.cat.ts.ui.docx.dialog;import java.io.File;import java.lang.reflect.InvocationTargetException;import java.text.MessageFormat;import java.util.ArrayList;import java.util.HashSet;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;import java.util.Map.Entry;import java.util.Set;import net.heartsome.cat.common.core.Constant;import net.heartsome.cat.common.file.XLFValidator;import net.heartsome.cat.common.resources.ResourceUtils;import net.heartsome.cat.common.ui.dialog.FileFolderSelectionDialog;import net.heartsome.cat.common.util.CommonFunction;import net.heartsome.cat.ts.core.file.RowIdUtil;import net.heartsome.cat.ts.core.file.XLFHandler;import net.heartsome.cat.ts.ui.dialog.HelpDialog;import net.heartsome.cat.ts.ui.docx.Activator;import net.heartsome.cat.ts.ui.docx.ImportDocx;import net.heartsome.cat.ts.ui.docx.common.CommentBean;import net.heartsome.cat.ts.ui.docx.common.DocxCommonFuction;import net.heartsome.cat.ts.ui.docx.common.DocxConstant;import net.heartsome.cat.ts.ui.docx.common.ErrorBean;import net.heartsome.cat.ts.ui.docx.common.FlagErrorException;import net.heartsome.cat.ts.ui.docx.common.RowBean;import net.heartsome.cat.ts.ui.docx.common.TagBean;import net.heartsome.cat.ts.ui.docx.resource.Messages;import net.heartsome.cat.ts.ui.xliffeditor.nattable.editor.HsMultiActiveCellEditor;import net.heartsome.cat.ts.ui.xliffeditor.nattable.editor.HsMultiCellEditorControl;import net.heartsome.cat.ts.ui.xliffeditor.nattable.editor.XLIFFEditorImplWithNatTable;import net.heartsome.cat.ts.util.ProgressIndicatorManager;import net.heartsome.xml.vtdimpl.VTDUtils;import org.eclipse.core.filesystem.EFS;import org.eclipse.core.internal.filesystem.local.LocalFile;import org.eclipse.core.resources.IFile;import org.eclipse.core.resources.IProject;import org.eclipse.core.resources.IResource;import org.eclipse.core.resources.IWorkspaceRoot;import org.eclipse.core.resources.ResourcesPlugin;import org.eclipse.core.runtime.CoreException;import org.eclipse.core.runtime.IProgressMonitor;import org.eclipse.core.runtime.IStatus;import org.eclipse.core.runtime.Path;import org.eclipse.core.runtime.Status;import org.eclipse.core.runtime.jobs.IJobChangeEvent;import org.eclipse.core.runtime.jobs.Job;import org.eclipse.core.runtime.jobs.JobChangeAdapter;import org.eclipse.jface.dialogs.IDialogConstants;import org.eclipse.jface.dialogs.IDialogSettings;import org.eclipse.jface.dialogs.MessageDialog;import org.eclipse.jface.dialogs.ProgressMonitorDialog;import org.eclipse.jface.layout.GridDataFactory;import org.eclipse.jface.layout.GridLayoutFactory;import org.eclipse.jface.operation.IRunnableWithProgress;import org.eclipse.jface.viewers.Viewer;import org.eclipse.jface.viewers.ViewerFilter;import org.eclipse.swt.SWT;import org.eclipse.swt.events.SelectionAdapter;import org.eclipse.swt.events.SelectionEvent;import org.eclipse.swt.layout.GridData;import org.eclipse.swt.layout.GridLayout;import org.eclipse.swt.widgets.Button;import org.eclipse.swt.widgets.Composite;import org.eclipse.swt.widgets.Control;import org.eclipse.swt.widgets.Display;import org.eclipse.swt.widgets.FileDialog;import org.eclipse.swt.widgets.Group;import org.eclipse.swt.widgets.Label;import org.eclipse.swt.widgets.Shell;import org.eclipse.swt.widgets.Text;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import com.ximpleware.AutoPilot;import com.ximpleware.VTDNav;import com.ximpleware.XMLModifier;public class ImportDocxDialog extends HelpDialog {private static final Logger LOGGER = LoggerFactory.getLogger(ImportDocxDialog.class);		private static final String STORE_DOCX_PATH = "net.heartsome.cat.ts.ui.docx.dialog.ImportDocxDialog.docxPath";	/** 用户工作空间根目录 */	private IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();		/** XLIFFEditorImplWithNatTable 实例  */	private XLIFFEditorImplWithNatTable xliffEditor;	/** 项目集合，值为项目的路径 */	private ArrayList<String> lstProject = new ArrayList<String>();	/** xliff 文件路径文本框 */	private Text xliffPathTxt;	/** xliff 文件浏览按钮 */	private Button browseXLIFFBtn;	/** RTF 文件路径文本框 */	private Text docxPathTxt;	/** RTF 文件浏览按钮 */	private Button browseDocxBtn;	/** 所选 xliff 文件的完整路径 */	private String xliffFullPath;		/** 所选 xliff 文件的相对路径 */	private String xliffRelativePath;		private XLFHandler xlfHandler = null;	private XLFHandler tempXlfHandler = null;	private String xliffPath;	private VTDNav vn;	private AutoPilot ap;	private VTDUtils vu;	private XMLModifier xm;	/** 错误行的集合 */	private List<ErrorBean> errorList = new ArrayList<ErrorBean>();	private Set<String> errorRowSet = new HashSet<String>();	private boolean continuImport = true;		/** 批注是否导出 */	private boolean hasComment;		public ImportDocxDialog(Shell parentShell, XLIFFEditorImplWithNatTable xliffEditor, String strXliffRelativePath, String strXliffFullPath) {		super(parentShell);		this.xliffEditor = xliffEditor;		this.xliffRelativePath = strXliffRelativePath;		this.xliffFullPath = strXliffFullPath;	}	@Override	protected void createButtonsForButtonBar(Composite parent) {		// ROBERTHELP 导入RTF		String language = CommonFunction.getSystemLanguage();		String helpUrl = MessageFormat.format(					"/net.heartsome.cat.ts.ui.help/html/{0}/ch05s05.html#import-rtf-to-xliff", language);		setHelpUrl(helpUrl);		super.createButtonsForButtonBar(parent);	}	@Override	protected void configureShell(Shell newShell) {		super.configureShell(newShell);		newShell.setText(Messages.getString("ImportDocxDialog.title"));	}		@Override	protected Control createDialogArea(Composite parent) {		Composite tparent = (Composite) super.createDialogArea(parent);		GridLayoutFactory.swtDefaults().extendedMargins(2, 2, 0, 0).numColumns(3).equalWidth(false).applyTo(tparent);		GridDataFactory.fillDefaults().hint(510, 120).grab(true, true).applyTo(tparent);		Group groupXLIFF = new Group(tparent, SWT.None);		GridData data = new GridData(GridData.FILL_HORIZONTAL);		data.horizontalSpan = 3;		groupXLIFF.setLayoutData(data);		groupXLIFF.setLayout(new GridLayout(3, false));		groupXLIFF.setText(Messages.getString("ImportDocxDialog.XLIFFgroup"));		Label lblXLIFF = new Label(groupXLIFF, SWT.None);		lblXLIFF.setText(Messages.getString("ImportDocxDialog.lable.xliff"));				xliffPathTxt = new Text(groupXLIFF, SWT.BORDER);		xliffPathTxt.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));		xliffPathTxt.setEditable(false);		if (xliffRelativePath != null) {			xliffPathTxt.setText(xliffRelativePath);		}		browseXLIFFBtn = new Button(groupXLIFF, SWT.None);		browseXLIFFBtn.setText(Messages.getString("ImportDocxDialog.browseXLIFFBtn"));		Label lblRTF = new Label(tparent, SWT.None);		lblRTF.setText(Messages.getString("ImportDocxDialog.label.docx"));		GridDataFactory.swtDefaults().align(SWT.RIGHT, SWT.CENTER).grab(false, false).applyTo(lblRTF);		docxPathTxt = new Text(tparent, SWT.BORDER);		docxPathTxt.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));		docxPathTxt.setEditable(false);		browseDocxBtn = new Button(tparent, SWT.None);		browseDocxBtn.setText(Messages.getString("ImportDocxDialog.browseDocxBtn"));				for (IProject project : root.getProjects()) {			lstProject.add(project.getLocation().toOSString());		}		initListener();		initRtfPath();		return tparent;	}		private void initRtfPath() {		IDialogSettings dialogSettings = Activator.getDefault().getDialogSettings();		String strRtfPath = dialogSettings.get(STORE_DOCX_PATH);		if (strRtfPath != null && !strRtfPath.trim().equals("")) {			docxPathTxt.setText(strRtfPath);		}	}	/**	 * 初始化按钮监听 ;	 */	private void initListener() {		browseXLIFFBtn.addSelectionListener(new SelectionAdapter() {			public void widgetSelected(SelectionEvent event) {				FileFolderSelectionDialog dialog = new FileFolderSelectionDialog(getShell(), false, IResource.FILE) {					// 打开对话框时展开树形目录					public void create() {						super.create();						super.getTreeViewer().expandAll();					}				};				dialog.setTitle(Messages.getString("ImportDocxDialog.browseXLIFFBtn.msg0"));				dialog.setMessage(Messages.getString("ImportDocxDialog.browseXLIFFBtn.msg1"));				dialog.setDoubleClickSelects(true);				dialog.setAllowMultiple(false);				try {					dialog.setInput(EFS.getStore(root.getLocationURI()));				} catch (CoreException e1) {					LOGGER.error(Messages.getString("ImportDocxDialog.LOGGER.logger1"), e1);				}				dialog.addFilter(new ViewerFilter() {					@SuppressWarnings("restriction")					@Override					public boolean select(Viewer viewer, Object parentElement, Object element) {						if (element instanceof LocalFile) {							LocalFile folder = (LocalFile) element;							if (folder.getName().equalsIgnoreCase(".hsConfig")									|| folder.getName().equalsIgnoreCase(".metadata")) {								return false;							}							if (lstProject.contains(folder.toString())) {								return true;							}							String xliffFolderPath = folder.toString();							for (String projectPath : lstProject) {								String path1 = projectPath + System.getProperty("file.separator") + Constant.FOLDER_XLIFF;								if (xliffFolderPath.startsWith(path1)) {									return true;								}							}						}						return false;					}				});				dialog.create();				dialog.open();				if (dialog.getResult() != null) {					Object obj = dialog.getFirstResult();					IFile file = root.getFileForLocation(Path.fromOSString(obj.toString()));					xliffPathTxt.setText(file.getFullPath().toOSString());					xliffFullPath = ResourceUtils.iFileToOSPath(file);				}			}		});		browseDocxBtn.addSelectionListener(new SelectionAdapter() {			public void widgetSelected(SelectionEvent e) {				FileDialog dialog = new FileDialog(getShell());				dialog.setText(Messages.getString("ImportDocxDialog.browseDocx.title"));				dialog.setFilterExtensions(new String[] { "*.docx", "*.*" });				dialog.setFilterNames(new String[] {Messages.getString(Messages.getString("ImportDocxDialog.browseDocx.filter"))});				String fileSep = System.getProperty("file.separator");				if (docxPathTxt.getText() != null && !docxPathTxt.getText().trim().equals("")) {					dialog.setFilterPath(docxPathTxt.getText().substring(0, docxPathTxt.getText().lastIndexOf(fileSep)));					dialog.setFileName(docxPathTxt.getText().substring(docxPathTxt.getText().lastIndexOf(fileSep) + 1));				} else {					dialog.setFilterPath(System.getProperty("user.home"));				}				String path = dialog.open();				if (path != null) {					docxPathTxt.setText(path);				}			}		});	}	@Override	protected void okPressed() {		if (xliffPathTxt.getText() == null || xliffPathTxt.getText().trim().equals("")) {			MessageDialog.openInformation(getShell(), Messages.getString("all.dialog.ok.title"),					Messages.getString("ImportDocxDialog.ok.msg0"));			return;		}				IDialogSettings dialogSettings = Activator.getDefault().getDialogSettings();		dialogSettings.put(STORE_DOCX_PATH, docxPathTxt.getText().trim());				XLFValidator.resetFlag();		if (!XLFValidator.validateXliffFile(xliffFullPath)) {			return;		}		XLFValidator.resetFlag();		final String docxPath = docxPathTxt.getText();		if (docxPath == null || docxPath.trim().equals("")) {			MessageDialog.openInformation(getShell(), Messages.getString("all.dialog.ok.title"),					Messages.getString("ImportDocxDialog.ok.msg1"));			return;		}		if (!new File(docxPath).exists()) {			MessageDialog.openWarning(getShell(), Messages.getString("all.dialog.warning"),					MessageFormat.format(Messages.getString("ImportDocxDialog.ok.msg2"), new Object[]{docxPath}));			return;		}				// 开始进行处理		IRunnableWithProgress runnable = new IRunnableWithProgress() {			public void run(IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {				try {					monitor.beginTask(Messages.getString("ImportDocxDialog.ok.monitor.msg0"), 10);					beginImport(docxPath);					monitor.done();				} catch (Exception e) {					LOGGER.error("", e);				}			}		};				try {			new ProgressMonitorDialog(getShell()).run(true, true, runnable);		} catch (Exception e) {			LOGGER.error("", e);		}		close();	}			/**	 * 开始导入功能	 */	public boolean beginImport(final String docxPath) throws Exception{		if (xliffEditor == null || xliffEditor.getXLFHandler() == null) {			xlfHandler = new XLFHandler();					}else {			xlfHandler = xliffEditor.getXLFHandler();			Display.getDefault().syncExec(new Runnable() {				@Override				public void run() {					HsMultiActiveCellEditor.commit(true);				}			});			xm = new XMLModifier(xlfHandler.getVnMap().get(xliffFullPath));			xlfHandler.saveAndReparse(xm, xliffFullPath);		}				// 开始解析　xliff 文件		tempXlfHandler = new XLFHandler();		parseXliff(tempXlfHandler);				// UNDO 这里还应判断导入时两个文件是否对应，		try {			ImportDocx importWord = new ImportDocx(docxPath, xliffFullPath);			List<RowBean> rowList = importWord.getDataFromWord();			hasComment = importWord.isHasComment();									// 现在开始判断每个tu 节点的标记是否异常。若有异常进行提示			rowListFor:for(RowBean rowBean : rowList){				String rowId = rowBean.getRowId();				if (rowId == null || rowId.length() <= 0) {					continue rowListFor;				}								if (curRowIsLocked(rowId)) {					rowBean.setLocked(true);					continue rowListFor;				}								String srcText = getSrcTextFromXliffByRowId(rowId);				List<String> xliffSrcTagList = getTagFromSrcText(srcText);				List<String> xliffTgtTagList = new ArrayList<String>();				xliffTgtTagList.addAll(xliffSrcTagList);								// 获取 rowBean　中源文的标记				List<TagBean> rowSrcTagList = new ArrayList<TagBean>();				for(Object object : rowBean.getSrcElement()){					if (object instanceof TagBean) {						rowSrcTagList.add((TagBean)object);					}				}								// 下面开始验证文本段				// 0、首先验证 word 文档中的当前行能否找到与之对应的　xliff　文件				if (srcText == null) {					errorList.add(new ErrorBean(rowBean.getIndex(), true, DocxConstant.ERROR_notFindTU));					errorRowSet.add(rowBean.getRowId());					continue rowListFor;				}								// 1、首先验证源文标记是否缺失				if (rowSrcTagList.size() < xliffSrcTagList.size()) {					errorList.add(new ErrorBean(rowBean.getIndex(), true, DocxConstant.ERROR_tagLose));					errorRowSet.add(rowBean.getRowId());					continue rowListFor;				}								// 2、验证word源文标记是否多出				if (rowSrcTagList.size() > xliffSrcTagList.size()) {					errorList.add(new ErrorBean(rowBean.getIndex(), true, DocxConstant.ERROR_tagMore));					errorRowSet.add(rowBean.getRowId());					continue rowListFor;				}								// 3、检查　word 源文本是否存在标记位置不对的情况，即成对标记开始与结束颠倒。				// 根据源文的标记信息，将 rowBean 中的标记补全				// UNDO 这里还应确定导出的标记是否发生改变				for(TagBean bean : rowSrcTagList){					String rowTagText = bean.getText();					for(int i = 0; i < xliffSrcTagList.size(); i ++){						String xlfTagText = xliffSrcTagList.get(i);						if (xlfTagText.indexOf(rowTagText) == 0) {							if (!xlfTagText.equals(rowTagText)) {								bean.setText(xlfTagText);							}							xliffSrcTagList.remove(i);							bean.setTagType(DocxCommonFuction.getTagType(xlfTagText));							break;						}					}				}				if (xliffSrcTagList.size() > 0) {					// docx 文档中的标记被更换了					errorList.add(new ErrorBean(rowBean.getIndex(), true, DocxConstant.ERROR_tagNotSame));					errorRowSet.add(rowBean.getRowId());					continue rowListFor;				}				int startTag = 0;				for(TagBean bean : rowSrcTagList){					if (bean.getTagType() == DocxConstant.PAIRSTAR) {						startTag ++;					}else if (bean.getTagType() == DocxConstant.PAIREND) {						startTag --;					}					if (startTag < 0) {						errorList.add(new ErrorBean(rowBean.getIndex(), true, DocxConstant.ERROR_tagPostionError));						errorRowSet.add(rowBean.getRowId());						continue rowListFor;					}				}								// 4、验证 目标文本段中标记错误，或者位置不对应的情况				// 先获得word 中目标文本中的标记				// 获取 rowBean　中源文的标记				List<TagBean> rowTgtTagList = new ArrayList<TagBean>();				for(Object object : rowBean.getTgtElement()){					if (object instanceof TagBean) {						rowTgtTagList.add((TagBean)object);					}				}				int modifiedTagSum = 0;				for(TagBean bean : rowTgtTagList){					String rowTagText = bean.getText();					// 因为标记不允许修改，因此在　xliff　中，目标文本中的标记就是源文中的标记					for(int i = 0; i < xliffTgtTagList.size(); i ++){						String xlfTagText = xliffTgtTagList.get(i);						if (xlfTagText.indexOf(rowTagText) == 0) {							if (!xlfTagText.equals(rowTagText)) {								bean.setText(xlfTagText);							}							xliffTgtTagList.remove(i);							modifiedTagSum ++;							bean.setTagType(DocxCommonFuction.getTagType(xlfTagText));							break;						}					}				}				if (modifiedTagSum != rowTgtTagList.size()) {					// docx 文档中的标记被更换了					errorList.add(new ErrorBean(rowBean.getIndex(), false, DocxConstant.ERROR_tagNotSame));					errorRowSet.add(rowBean.getRowId());					continue rowListFor;				}				startTag = 0;				for(TagBean bean : rowTgtTagList){					if (bean.getTagType() == DocxConstant.PAIRSTAR) {						startTag ++;					}else if (bean.getTagType() == DocxConstant.PAIREND) {						startTag --;					}					if (startTag < 0) {						errorList.add(new ErrorBean(rowBean.getIndex(), false, DocxConstant.ERROR_tagPostionError));						errorRowSet.add(rowBean.getRowId());						continue rowListFor;					}				}				if (startTag != 0) {					errorList.add(new ErrorBean(rowBean.getIndex(), false, DocxConstant.ERROR_pairTagError));					errorRowSet.add(rowBean.getRowId());				}			}						// 验证完后，开始导入功能，如果有错误提示信息，开始提示			if (errorList.size() > 0) {				StringBuffer errorSB = new StringBuffer();				errorSB.append(Messages.getString("ImportDocxDialog.import.errorTip1"));				for(ErrorBean bean : errorList){					errorSB.append(MessageFormat.format(Messages.getString("ImportDocxDialog.import.errorTip2"), bean.getIndex()));										if (bean.getErrorType() == DocxConstant.ERROR_notFindTU) {						errorSB.append(Messages.getString("ImportDocxDialog.import.errorTip3"));						continue;					}										if (bean.isSrc()) {						errorSB.append(Messages.getString("ImportDocxDialog.import.errorTip4"));					}else {						errorSB.append(Messages.getString("ImportDocxDialog.import.errorTip5"));					}										switch (bean.getErrorType()) {					case DocxConstant.ERROR_tagLose:						errorSB.append(Messages.getString("ImportDocxDialog.import.errorTip6"));						break;					case DocxConstant.ERROR_tagMore:						errorSB.append(Messages.getString("ImportDocxDialog.import.errorTip7"));						break;					case DocxConstant.ERROR_tagPostionError:						errorSB.append(Messages.getString("ImportDocxDialog.import.errorTip8"));						break;					case DocxConstant.ERROR_tagNotSame:						errorSB.append(Messages.getString("ImportDocxDialog.import.errorTip9"));						break;					case DocxConstant.ERROR_pairTagError:						errorSB.append(Messages.getString("ImportDocxDialog.import.errorTip11"));						break;					default:						break;					}				}				errorSB.append(Messages.getString("ImportDocxDialog.import.errorTip10"));				final String errorTip = errorSB.toString();				Display.getDefault().syncExec(new Runnable() {					@Override					public void run() {						ErrorTipDialog errorDialog = new ErrorTipDialog(getShell(), errorTip);						int result = errorDialog.open();												if (result == IDialogConstants.CANCEL_ID) {							continuImport = false;						}					}				});								if (!continuImport) {					return false;				}								String rowId = "";				// 先将　有错误的文本段进行清除				for (int i = 0; i < rowList.size(); i++) {					rowId = rowList.get(i).getRowId();					if (errorRowSet.contains(rowId)) {						rowList.remove(i);						i --;					}				}			}			importDocxToXliffList(rowList);						if (xliffEditor != null) {				parseXliff(xlfHandler);				Display.getDefault().syncExec(new Runnable() {					@Override					public void run() {						xliffEditor.reloadData();						HsMultiCellEditorControl.activeSourceAndTargetCell(xliffEditor);					}				});			}		} catch (final FlagErrorException e) {			Display.getDefault().syncExec(new Runnable() {				@Override				public void run() {					MessageDialog.openWarning(Display.getDefault().getActiveShell(), 							Messages.getString("all.dialog.warning"), e.getMessage());				}			});			LOGGER.error(e.getMessage(), e);			return false;		} catch (Exception e) {			LOGGER.error(Messages.getString("ImportDocxDialog.LOGGER.logger2"),					e);		}				return true;	}			/**	 * 	 * @param xlfHandler	 * @return	 * @throws Exception	 */	private boolean parseXliff(XLFHandler xlfHandler) throws Exception{		Map<String, Object> resultMap = xlfHandler.openFile(xliffFullPath);		if (resultMap == null || Constant.RETURNVALUE_RESULT_SUCCESSFUL != (Integer) resultMap.get(Constant.RETURNVALUE_RESULT)) {			// 打开文件失败。			Display.getDefault().syncExec(new Runnable() {				public void run() {					MessageDialog.openWarning(getShell(), Messages.getString("all.dialog.warning"), 							MessageFormat.format(Messages.getString("ImportDocxDialog.ok.parseError"), xliffRelativePath));					LOGGER.error(MessageFormat.format(Messages.getString("ImportDocxDialog.ok.parseError"), xliffRelativePath));				}			});			return false;		}				vn = xlfHandler.getVnMap().get(xliffFullPath);		ap = new AutoPilot(vn);		vu = new VTDUtils(vn);		xm = new XMLModifier(vn);				return true;	}			/**	 * 根据传入的　rowId 从　xliff 中获取当前文本段是否处理锁定状态，如果是锁定的，将不予更新。	 * @param rowId	 * @return	 */	private boolean curRowIsLocked(String rowId) throws Exception{		ap.selectXPath(RowIdUtil.parseRowIdToXPath(rowId));		if (ap.evalXPath() != -1) {			int index = -1;			if ((index = vn.getAttrVal("translate")) != -1) {				return "no".equalsIgnoreCase(vn.toRawString(index));			}		}		return false;	}		/**	 * 根据传入的　rowId　获取源文文本段	 * @param rowId	 * @return	<div style='color:red'>备注：如果返回为 null，证明无法找到对应的　tu 节点</div>	 */	private String getSrcTextFromXliffByRowId(String rowId) throws Exception{		String srcText = null;		ap.selectXPath(RowIdUtil.parseRowIdToXPath(rowId)); 		if (ap.evalXPath() != -1) {			ap.selectXPath("./source");			if (ap.evalXPath() != -1) {				srcText = vu.getElementContent();			}		}		return srcText;	}			/**	 * 该方法与类 {@link #ananysisTextWithTag} 类似	 * @param srcText	 * @return	 */	private List<String> getTagFromSrcText(String srcText){		List<String> tagList = new ArrayList<String>();		if (srcText == null) {			return tagList;		}				// 先不管是什么标记，按照　xml 的标记，把文本段中的节点提取出来。		int index = srcText.indexOf("<");		Map<Integer, TagBean> tagMap = new LinkedHashMap<Integer, TagBean>();		int tagType = -1;		while (index != -1) {			int endIndex = srcText.length();			int end_1 = srcText.indexOf(">", index + 1);			int end_2 = srcText.indexOf("\\>", index + 1);			endIndex = end_1 != -1 ? (endIndex < end_1 ? endIndex : end_1) : endIndex;			endIndex = end_2 != -1 ? (endIndex < end_2 ? endIndex : end_2) : endIndex;			String tagText = srcText.substring(index, endIndex + 1);						if (tagText.indexOf("/>") != -1) {				tagType = DocxConstant.NOTPAIR;			}else if (tagText.indexOf("</") != -1) {				tagType = DocxConstant.PAIREND;			}else {				tagType = DocxConstant.PAIRSTAR;			}						tagMap.put(index, new TagBean(index, endIndex, tagType, tagText));			index = srcText.indexOf("<", index + 1);		}				// 开始处理　<ph> 标记的特殊情况		TagBean bean = null;		Integer[] keyArray = tagMap.keySet().toArray(new Integer[]{});		int key = -1;		for (int i = 0; i < keyArray.length; i++) {			key = keyArray[i];			bean = tagMap.get(key);			if (bean.getText().indexOf("<ph") != -1 && bean.getTagType() == DocxConstant.PAIRSTAR) {				int start = bean.getStartIndex();				int end = bean.getEndIndex();								int nextPhEndTagIdx = i + 1;				while(nextPhEndTagIdx <= keyArray.length){					TagBean nextBean = tagMap.get(keyArray[nextPhEndTagIdx]);					tagMap.remove(keyArray[nextPhEndTagIdx]);					if (nextBean.getText().indexOf("</ph") != -1) {						int nextEnd = nextBean.getEndIndex();						end = nextEnd;						String newText = srcText.substring(start, end + 1);						bean.setTagType(DocxConstant.NOTPAIR);						bean.setEndIndex(end);						bean.setText(newText);						i = nextPhEndTagIdx;						break;					}					nextPhEndTagIdx ++;				}			}		}				// 开始将所有标记装入结果集合中		bean = null;		for (Entry<Integer, TagBean> entry : tagMap.entrySet()) {			tagList.add(entry.getValue().getText());		}				return tagList;	}			/**	 * 将数据从 docx 中导入　xliff 文件。	 */	private void importDocxToXliffList(List<RowBean> rowList) throws Exception{		String rowId = "";		StringBuffer contentSB = new StringBuffer();		for(RowBean bean : rowList){			rowId = bean.getRowId();			if (bean.isLocked()) {				continue;			}						if (rowId == null || rowId.length() <= 0) {				continue;			}						ap.selectXPath(RowIdUtil.parseRowIdToXPath(rowId));			if (ap.evalXPath() != -1) {				// 开始处理源文本				contentSB = new StringBuffer();				vn.push();				ap.selectXPath("./source");				if (ap.evalXPath() != -1) {					String header = vu.getElementHead();					contentSB.append(header);					for(Object object : bean.getSrcElement()){						if (object instanceof TagBean) {							contentSB.append(((TagBean) object).getText());						}else {							contentSB.append(object);						}					}					contentSB.append("</source>");					xm.remove();				}				vn.pop();								// 开始处理目标文本段				ap.selectXPath("./target");				if (ap.evalXPath() != -1) {					String header = vu.getElementHead();					contentSB.append(header);					for(Object object : bean.getTgtElement()){						if (object instanceof TagBean) {							contentSB.append(((TagBean) object).getText());						}else {							contentSB.append(object);						}					}					contentSB.append("</target>");					xm.remove();					xm.insertAfterElement(contentSB.toString());				}else {					contentSB.append("<target>");					for(Object object : bean.getTgtElement()){						if (object instanceof TagBean) {							contentSB.append(((TagBean) object).getText());						}else {							contentSB.append(object);						}					}					contentSB.append("</target>");										xm.insertBeforeTail(contentSB.toString());				}			}		}				tempXlfHandler.saveAndReparse(xm, xliffFullPath);		parseXliff(tempXlfHandler);				// 再处理状态与批注的问题		ananysisStatusAndComment(rowList);		tempXlfHandler.saveAndReparse(xm, xliffFullPath);	}			/**	 * 处理状态以及批注	 * @param rowList	 */	private void ananysisStatusAndComment(List<RowBean> rowList) throws Exception{		String rowId = "";				for(RowBean bean : rowList){			if (bean.isLocked()) {				continue;			}			rowId = bean.getRowId();			if (rowId == null || rowId.length() <= 0) {				continue;			}						int status = -1;			boolean targetNull = true;			ap.selectXPath(RowIdUtil.parseRowIdToXPath(rowId));			if (ap.evalXPath() != -1) {				// 先处理状态				// 检查　target 是否为空				vn.push();				ap.selectXPath("./target[text()!='' or *]");				if (ap.evalXPath() != -1) {					targetNull = false;				}				vn.pop();								// 如果译文为空，那状态应为未翻译，如果译文不为空，那状态应不为未翻译				if (targetNull) {					status = DocxConstant.STATUS_unstrans;				}								setOtherStatus(status);								if (hasComment) {					// 处理批注的问题。					// 首先删除所有批注					vn.push();					ap.selectXPath("./note");					while(ap.evalXPath() != -1){						xm.remove();					}					StringBuffer commentSB = new StringBuffer();										if (bean.getComment() != null) {						for(CommentBean commentBean : bean.getComment()){							// <note from='Mac'>2013-05-13:test</note>							commentSB.append("<note from='");							commentSB.append(commentBean.getUser() + "'>");							commentSB.append(commentBean.getTime() + ":" + commentBean.getText());							commentSB.append("</note>");						}					}					vn.pop();					if (commentSB.length() > 0) {						xm.insertBeforeTail(commentSB.toString());					}				}							}		}	}		/**	 * 处理状态，若译文为空，将状态更改成未翻译，若不为空，将状态更改成其他	 */	private void setOtherStatus(int status) throws Exception{		vn.push();		int index = -1;				if (status == DocxConstant.STATUS_unstrans) {			// 如果变成了未翻译，那就删除如下属性　translate　approved　state			if ((index = vn.getAttrVal("approved")) != -1) {				xm.removeAttribute(index - 1);			}			vn.push();			ap.selectXPath("./target");			if (ap.evalXPath() != -1) {				if ((index = vn.getAttrVal("state")) != -1) {					xm.removeAttribute(index - 1);				}			}			vn.pop();		}else {			// 如果不是未翻译，则检查是否是草稿以上的状态			vn.push();			ap.selectXPath("./target");			if (ap.evalXPath() != -1) {				if ((index = vn.getAttrVal("state")) == -1) {					xm.insertAttribute(" state=\"new\"");				}			}			vn.pop();		}				vn.pop();	}		}